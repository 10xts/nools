{"name":"Nools","body":"#Nools\r\n\r\nNools is a rules engine for node based on the [rete](http://en.wikipedia.org/wiki/Rete_algorithm) network.\r\n\r\n# Installation\r\n\r\n    npm install nools\r\n\r\n\r\n#Usage\r\n\r\n   * Flows\r\n    * [Defining A Flow](#flow) \r\n    * [Sessions](#session) \r\n    * [Facts](#facts) \r\n    * [Firing](#firing) \r\n    * [Disposing](#disposing) \r\n   * [Defining Rules](#defining-rule)\r\n      * [Structure](#rule-structure) \r\n      * [Constraints](#constraints)\r\n      * [Actions](#action)\r\n   * [Fibonacci](#fib)\r\n      \r\n   \r\n\r\nTo get started with nools the [examples](https://github.com/doug-martin/nools/tree/master/examples) and [tests](https://github.com/doug-martin/nools/tree/master/test) are a \r\ngreat place to get started.\r\n\r\n<a name=\"flow\"></a>\r\n##Defining a flow\r\n\r\nWhen using nools you define a **flow** which acts as a container for rules that can later be used to get\r\nan **engine session**\r\n\r\n###Pragmatically\r\n```javascript\r\nvar nools = require(\"nools\");\r\n\r\nvar Message = function (message) {\r\n    this.message = message;\r\n};\r\n\r\nvar flow = nools.flow(\"Hello World\", function (flow) {\r\n\r\n    //find any message that start with hello\r\n    this.rule(\"Hello\", [Message, \"m\", \"m.message =~ /^hello(\\\\s*world)?$/\"], function (facts) {\r\n        facts.m.message = facts.m.message + \" goodbye\";\r\n        this.modify(facts.m);\r\n    });\r\n\r\n    //find all messages then end in goodbye\r\n    this.rule(\"Goodbye\", [Message, \"m\", \"m.message =~ /.*goodbye$/\"], function (facts) {\r\n        console.log(facts.m.message);\r\n    });\r\n});\r\n\r\n```\r\n\r\nIn the above flow definition 2 rules were defined\r\n\r\n  * Hello\r\n    * Requires a Message\r\n    * The messages's message must match the regular expression \"/^hello(\\\\s*world)?$/\"\r\n    * When matched the message's message is modified and then we let the engine know that we modified the message.\r\n  * Goodbye\r\n    * Requires a Message\r\n    * The messages's message must match the regular expression \"/.*goodbye$/\"(anything that ends in goodbye)\r\n    * When matched the resulting message is logged.\r\n\r\n###Nools \r\n\r\nYou may also use the `nools` rules language to define your rules\r\n\r\n```\r\ndefine Message {\r\n    message : '',\r\n    constructor : function(message){\r\n        this.message = message;\r\n    }    \r\n}\r\n\r\nrule Hello {\r\n    when {\r\n        m : Message m.message =~ /^hello(\\\\s*world)?$/;\r\n    }\r\n    then {\r\n        modify(m, function(){this.message += \" goodbye\";});\r\n    }\r\n}\r\n\r\nrule Goodbye {\r\n    when {\r\n        m : Message m.message =~ /.*goodbye$/;\r\n    }\r\n    then {\r\n        console.log(m.message);\r\n    }\r\n}\r\n```\r\n\r\nTo use the flow\r\n\r\n```javascript\r\nvar flow = nools.compile(__dirname + \"/helloworld.nools\"),\r\n    Message = flow.getDefined(\"message\");\r\n```\r\n    \r\n\r\n\r\n<a name=\"session\"></a>\r\n##Working with a session\r\n\r\nA session is an instance of the flow that contains a working memory and handles the assertion, modification, and retraction\r\nof facts from the engine.\r\n\r\nTo obtain an engine session from the flow invoke the **getSession** method.\r\n\r\n```javascript\r\nvar session = flow.getSession();\r\n```\r\n\r\n\r\n<a name=\"facts\"></a>\r\n##Working with facts\r\n\r\nFacts are items that the rules should try to match.\r\n\r\n\r\nTo add facts to the session use **assert** method.\r\n\r\n```javascript\r\nsession.assert(new Message(\"hello\"));\r\nsession.assert(new Message(\"hello world\"));\r\nsession.assert(new Message(\"goodbye\"));\r\n```\r\n\r\nAs a convenience any object passed into **getSession** will also be asserted.\r\n\r\n```javascript\r\nflow.getSession(new Message(\"hello\"), new Message(\"hello world\"), new Message(\"goodbye\"));\r\n```\r\n\r\n\r\nTo retract facts from the session use the **retract** method.\r\n\r\n```javascript\r\nvar m = new Message(\"hello\");\r\n\r\n//assert the fact into the engine\r\nsession.assert(m);\r\n\r\n//remove the fact from the engine\r\nsession.retract(m);\r\n\r\n```\r\n\r\nTo modify a fact use the **modify** method.\r\n\r\n**Note** modify will not work with immutable objects (i.e. strings). \r\n\r\n```javascript\r\n\r\nvar m = new Message(\"hello\");\r\n\r\nsession.assert(m);\r\n\r\nm.message = \"hello goodbye\";\r\n\r\nsession.modify(m);\r\n\r\n```\r\n\r\n**assert** is typically used pre engine execution and during the execution of the rules.\r\n\r\n**modify** and **retract** are typically used during the execution of the rules.\r\n\r\n\r\n<a name=\"firing\"></a>\r\n##Firing the rules\r\n\r\nWhen you get a session from a **flow** no rules will be fired until the **match** method is called.\r\n\r\n```javascript\r\nvar session = flow.getSession();\r\n//assert your different messages\r\nsession.assert(new Message(\"goodbye\"));\r\nsession.assert(new Message(\"hello\"));\r\nsession.assert(new Message(\"hello world\"));\r\n\r\n//now fire the rules\r\nsession.match(function(err){\r\n    if(err){\r\n        console.error(err);\r\n    }else{\r\n        console.log(\"done\");\r\n    }\r\n})\r\n```\r\n\r\nThe **match** method returns a promise that is invoked once there are no more rules to activate. \r\n\r\nExample of the promise api\r\n```javascript\r\nsession.match().then(\r\n  function(){\r\n      console.log(\"Done\");\r\n  }, \r\n  function(err){\r\n    //uh oh an error occurred\r\n    console.error(err);\r\n  });\r\n```\r\n\r\n<a name=\"disposing\"></a>\r\n##Disposing of the session\r\n\r\nWhen working with a lot of facts it is wise to call the **dispose** method which will purge the current session of\r\nall facts, this will help prevent the process growing a large memory footprint.\r\n\r\n```javascript\r\n   session.dispose();\r\n```\r\n\r\n<a name=\"defining-rule\"></a>\r\n#Defining rules\r\n\r\n\r\n<a name=\"rule structure\"></a>\r\n## Rule structure\r\n\r\nLets look at the \"Calculate\" rule in the [Fibonacci](#fib) example\r\n\r\n```javascript\r\n   //flow.rule(type[String|Function], constraints[Array|Array[[]]], action[Function]);\r\n   flow.rule(\"Calculate\", [\r\n         //Type     alias  pattern           store sequence to s1\r\n        [Fibonacci, \"f1\",  \"f1.value != -1\", {sequence:\"s1\"}],\r\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\r\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\r\n        [Result, \"r\"]\r\n    ], function (facts) {\r\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\r\n        var v = f3.value = f1.value + facts.f2.value;\r\n        facts.r.result = v;\r\n        this.modify(f3);\r\n        this.retract(f1);\r\n    });\r\n```\r\n\r\nOr using the nools DSL\r\n\r\n```\r\nrule Calculate{\r\n    when {\r\n        f1 : Fibonacci f1.value != -1 {sequence:s1};\r\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\r\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\r\n    }\r\n    then {\r\n       modify(f3, function(){\r\n            this.value = f1.value + f2.value;\r\n       });\r\n       retract(f1);\r\n    }\r\n}\r\n```\r\n\r\n<a name=\"constraints\"></a>\r\n###Constraints\r\n   Constraints define what facts the rule should match. The constraint is a array of either a single constraint (i.e. Bootstrap rule)\r\n   or an array of constraints(i.e. Calculate).\r\n\r\nPrgamatically\r\n```javascript\r\n[\r\n   //Type     alias  pattern           store sequence to s1\r\n  [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\r\n  [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\r\n  [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\r\n  [Result, \"r\"]\r\n]\r\n```\r\n\r\nUsing nools DSL\r\n```\r\nwhen {\r\n    f1 : Fibonacci f1.value != -1 {sequence:s1};\r\n    f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\r\n    f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\r\n}\r\n```\r\n\r\n   1. Type -  is the Object type the rule should match. The available types are\r\n      * `String` - \"string\", \"String\", String\r\n      * `Number` - \"number\", \"Number\", Number\r\n      * `Boolean` - \"boolean\", \"Boolean\", Boolean\r\n      * `Date` - \"date\", \"Date\", Date\r\n      * `RegExp` - \"regexp\", \"RegExp\", RegExp\r\n      * `Array` - \"array\", \"Array\", [], Array\r\n      * `Object` - \"object\", \"Object\", \"hash\", Object\r\n      * Custom - any custom type that you define\r\n   2. Alias - the name the object should be represented as.\r\n   3. Pattern(optional) - The pattern that should evaluate to a boolean, the alias that was used should be used to reference the object in the pattern. Strings should be in single quotes, regular expressions are allowed. Any previously define alias/reference can be used within the pattern. Available operators are.\r\n      * `&&`, `AND`, `and`\r\n      * `||`, `OR`, `or`\r\n      * `>`, `<`, `>=`, `<=`, `gt`, `lt`, `gte`, `lte`\r\n      * `==`, `!=`, `=~`, `eq`, `neq`, `like`\r\n      * `+`, `-`, `*`, `/`\r\n      * `-` (unary minus)\r\n      * `.` (member operator)\r\n      * `in` (check inclusion in an array)\r\n      * Defined helper functions\r\n        * `now` - the current date\r\n        * `Date(year?, month?, day?, hour?, minute?, second?, ms?)` - creates a new `Date` object\r\n        * `lengthOf(arr, length)` - checks the length of an array\r\n        * `isTrue(something)` - check if something === true         \r\n        * `isFalse(something)` - check if something === false\r\n        * `isRegExp(something)` - check if something is a `RegExp`\r\n        * `isArray(something)` - check if something is an `Array`                                \r\n        * `isNumber(something)` - check if something is an `Number`\r\n        * `isHash(something)` - check if something is strictly an `Object`\r\n        * `isObject(something)` - check if something is any type of `Object`\r\n        * `isDate(something)` - check if something is a `Date`\r\n        * `isBoolean(something)` - check if something is a `Boolean`\r\n        * `isString(something)` - check if something is a `String`\r\n        * `isUndefined(something)` - check if something is a `undefined`\r\n        * `isDefined(something)` - check if something is `Defined`\r\n        * `isUndefinedOrNull(something)` - check if something is a `undefined` or `null`\r\n        * `isPromiseLike(something)` - check if something is a \"promise\" like (containing `then`, `addCallback`, `addErrback`)\r\n        * `isFunction(something)` - check if something is a `Function`\r\n        * `isNull(something)` - check if something is `null`\r\n        * `isNotNull(something)` - check if something is not null\r\n        * `dateCmp(dt1, dt2)` - compares two dates return 1, -1, or 0\r\n        * `years|months|days|hours|minutes|seconds``Ago`/`FromNow``(interval)` - adds/subtracts the date unit from the current time \r\n        \r\n   4. Reference(optional) - An object where the keys are properties on the current object, and values are aliases to use. The alias may be used in succeeding patterns.\r\n\r\n<a name=\"action\"></a>\r\n###Action\r\n\r\nThe action is a function that should be fired when all patterns in the rule match. The action is called in the scope\r\nof the engine so you can use **this** to **assert**, **modify**, or **retract** facts. An object containing all facts and\r\nreferences created by the alpha nodes is passed in as the first argument to the action.\r\n\r\nSo calculate's action modifies f3 by adding the value of f1 and f2 together and modifies f3 and retracts f1.\r\n\r\n```javascript\r\nfunction (facts) {\r\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\r\n        var v = f3.value = f1.value + facts.f2.value;\r\n        facts.r.result = v;\r\n        this.modify(f3);\r\n        this.retract(f1);\r\n    }\r\n```\r\n\r\nThe engine is also passed in as a second argument so alternatively you could do the following.\r\n\r\n```javascript\r\nfunction (facts, engine) {\r\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\r\n        var v = f3.value = f1.value + facts.f2.value;\r\n        facts.r.result = v;\r\n        engine.modify(f3);\r\n        engine.retract(f1);\r\n    }\r\n```\r\n\r\nIf you have an async action that needs to take place an optional third argument can be passed in which is a function \r\nto be called when the action is completed.\r\n\r\n```javascript\r\nfunction (facts, engine, next) {\r\n        //some async action\r\n        process.nextTick(function(){\r\n            var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\r\n            var v = f3.value = f1.value + facts.f2.value;\r\n            facts.r.result = v;\r\n            engine.modify(f3);\r\n            engine.retract(f1);\r\n            next();\r\n        })\r\n    }\r\n```\r\nIf any arguments are passed into next it is assumed there was an error and the session will error out.\r\n\r\nTo define the action with the nools DSL\r\n\r\n```\r\nthen {\r\n    modify(f3, function(){\r\n        this.value = f1.value + f2.value;\r\n    });\r\n    retract(f1);\r\n}\r\n```\r\n\r\nFor rules defined using the rules language nools will automatically determine what parameters need to be passed in based on what is referenced in the action.\r\n\r\n\r\n\r\n#Examples\r\n\r\n<a name=\"fib\"></a>\r\n##Fibonacci\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nvar nools = require(\"nools\");\r\n\r\nvar Fibonacci = function (sequence, value) {\r\n    this.sequence = sequence;\r\n    this.value = value || -1;\r\n};\r\n\r\nvar Result = function (result) {\r\n    this.result = result || -1;\r\n};\r\n\r\n\r\nvar flow = nools.flow(\"Fibonacci Flow\", function (flow) {\r\n\r\n    flow.rule(\"Recurse\", {priority:1}, [\r\n        [\"not\", Fibonacci, \"f\", \"f.sequence == 1\"],\r\n        [Fibonacci, \"f1\", \"f1.sequence != 1\"]\r\n    ], function (facts) {\r\n        var f2 = new Fibonacci(facts.f1.sequence - 1);\r\n        this.assert(f2);\r\n    });\r\n\r\n    flow.rule(\"Bootstrap\", [\r\n          Fibonacci, \"f\", \"f.value == -1 && (f.sequence == 1 || f.sequence == 2)\"\r\n    ], function (facts) {\r\n        var f = facts.f;\r\n        f.value = 1;\r\n        this.modify(f);\r\n    });\r\n\r\n    flow.rule(\"Calculate\", [\r\n        [Fibonacci, \"f1\", \"f1.value != -1\", {sequence:\"s1\"}],\r\n        [Fibonacci, \"f2\", \"f2.value != -1 && f2.sequence == s1 + 1\", {sequence:\"s2\"}],\r\n        [Fibonacci, \"f3\", \"f3.value == -1 && f3.sequence == s2 + 1\"],\r\n        [Result, \"r\"]\r\n    ], function (facts) {\r\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\r\n        var v = f3.value = f1.value + facts.f2.value;\r\n        facts.r.result = v;\r\n        this.modify(f3);\r\n        this.retract(f1);\r\n    });\r\n});\r\n\r\nvar r1 = new Result(),\r\n    session1 = flow.getSession(new Fibonacci(10), r1),\r\n    s1 = new Date;\r\nsession1.match().then(function () {\r\n    console.log(\"%d [%dms]\", r1.result, new Date - s1);\r\n    session1.dispose();\r\n});\r\n\r\nvar r2 = new Result(),\r\n    session2 = flow.getSession(new Fibonacci(150), r2),\r\n    s2 = new Date;\r\nsession2.match().then(function () {\r\n    console.log(\"%d [%dms]\", r2.result, new Date - s2);\r\n    session2.dispose();\r\n});\r\n\r\nvar r3 = new Result(),\r\n    session3 = flow.getSession(new Fibonacci(1000), r3),\r\n    s3 = new Date;\r\nsession3.match().then(function () {\r\n    console.log(\"%d [%dms]\", r3.result, new Date - s3);\r\n    session3.dispose();\r\n});\r\n\r\n```\r\n\r\nOutput\r\n\r\n```\r\n55 [43ms]\r\n9.969216677189305e+30 [383ms]\r\n4.346655768693743e+208 [3580ms]\r\n```\r\n\r\nFiboncci with nools DSL\r\n\r\n```\r\n//Define our object classes, you can\r\n//also declare these outside of the nools\r\n//file by passing them into the compile method\r\ndefine Fibonacci {\r\n    value:-1,\r\n    sequence:null\r\n}\r\ndefine Result {\r\n    value : -1\r\n}\r\n\r\nrule Recurse {\r\n    priority:1,\r\n    when {\r\n        //you can use not or or methods in here\r\n        not(f : Fibonacci f.sequence == 1);\r\n        //f1 is how you can reference the fact else where\r\n        f1 : Fibonacci f1.sequence != 1;\r\n    }\r\n    then {\r\n        assert(new Fibonacci({sequence : f1.sequence - 1}));\r\n    }\r\n}\r\n\r\nrule Bootstrap {\r\n   when {\r\n       f : Fibonacci f.value == -1 && (f.sequence == 1 || f.sequence == 2);\r\n   }\r\n   then{\r\n       modify(f, function(){\r\n           this.value = 1;\r\n       });\r\n   }\r\n}\r\n\r\nrule Calculate {\r\n    when {\r\n        f1 : Fibonacci f1.value != -1 {sequence : s1};\r\n        //here we define constraints along with a hash so you can reference sequence\r\n        //as s2 else where\r\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\r\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\r\n        r : Result\r\n    }\r\n    then {\r\n        modify(f3, function(){\r\n            this.value = r.result = f1.value + f2.value;\r\n        });\r\n        retract(f1);\r\n    }\r\n}\r\n\r\n```\r\n\r\nAnd to run\r\n\r\n```javascript\r\nvar flow = nools.compile(__dirname + \"/fibonacci.nools\");\r\n\r\nvar Fibonacci = flow.getDefined(\"fibonacci\"), Result = flow.getDefined(\"result\");\r\nvar r1 = new Result(),\r\n    session1 = flow.getSession(new Fibonacci({sequence:10}), r1),\r\n    s1 = +(new Date());\r\nsession1.match().then(function () {\r\n    console.log(\"%d [%dms]\", r1.result, +(new Date()) - s1);\r\n    session1.dispose();\r\n});\r\n\r\nvar r2 = new Result(),\r\n    session2 = flow.getSession(new Fibonacci({sequence:150}), r2),\r\n    s2 = +(new Date());\r\nsession2.match().then(function () {\r\n    console.log(\"%d [%dms]\", r2.result, +(new Date()) - s2);\r\n    session2.dispose();\r\n});\r\n\r\nvar r3 = new Result(),\r\n    session3 = flow.getSession(new Fibonacci({sequence:1000}), r3),\r\n    s3 = +(new Date());\r\nsession3.match().then(function () {\r\n    console.log(\"%d [%dms]\", r3.result, +(new Date()) - s3);\r\n    session3.dispose();\r\n});\r\n\r\n```\r\n\r\nLicense\r\n-------\r\n\r\nMIT <https://github.com/Pollenware/nools/raw/master/LICENSE>\r\n\r\nMeta\r\n----\r\n\r\n* Code: `git clone git://github.com/Pollenware/nools.git`\r\n","tagline":"Rete based rules engine for node.js","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}